import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
// Add CSS import for animations if not already included in your app
import './styles/animations.css';
import './App.css';

import LandingPage from './components/LandingPage';
import UserInformationPage from './components/UserInformationPage';
import { useAuth } from './contexts/AuthContext';
import AppLayout from './components/AppLayout';

// Add these imports at the top of your file
import { 
  TRANSACTION_TYPES,
  categorizeTransaction, 
  calculateVolume, 
  calculateGasFees,
  calculateUniqueTokens,
  groupTransactions 
} from './utils/transactionUtils';

import { Connection, PublicKey, LAMPORTS_PER_SOL } from '@solana/web3.js';

import calculateTaxes from './calculateTaxes';

import priceService from './services/priceService';

import TransactionDashboard from './components/TransactionDashboard.js';

import { getUserWallets, saveTransactions } from './services/databaseService';

import throttledQueue from 'throttled-queue';

import tokenRegistryService from './services/tokenRegistryService';

// At the top of the file with the other imports, add:
import { getConnection, validateWalletAddress, resetConnection, executeWithRetry, checkHeliusHealth } from './services/solanaConnectionService';

const CACHE_KEY_PREFIX = 'solana_tx_';
const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours

const SOLANA_RPC_ENDPOINT = 'https://rpc.helius.xyz/?api-key=268519a5-accf-40b1-9fe3-d0d61fe3a5ce';
// Extract the API key for direct use with their API endpoints
const HELIUS_API_KEY = '268519a5-accf-40b1-9fe3-d0d61fe3a5ce';

// Updated endpoints for Helius - use v0 for transactions
const HELIUS_RPC_URL = `https://api.helius.xyz/v1/rpc?api-key=${HELIUS_API_KEY}`;
const HELIUS_TRANSACTION_URL = `https://api.helius.xyz/v0/transactions?api-key=${HELIUS_API_KEY}`;
// Also add this endpoint for direct wallet transaction history - use a format that doesn't need replacement
const HELIUS_WALLET_TRANSACTIONS_URL = `https://api.helius.xyz/v0/addresses/`;

// Make the endpoint available globally for the connection service
window.SOLANA_RPC_ENDPOINT = SOLANA_RPC_ENDPOINT;

// Debug mode - set to true to enable additional logging
const DEBUG_MODE = true;

const RATE_LIMIT = {
  WALLET_DELAY: 3000,      // Increased from 2000ms to 3000ms
  REQUEST_DELAY: 1000,     // Increased from 500ms to 1000ms
  BATCH_DELAY: 2000,       // Increased from 1500ms to 2000ms
  MAX_RETRIES: 8,          // Increased from 5 to 8
  INITIAL_BACKOFF: 2500,   // Increased from 2000ms to 2500ms
  CONCURRENT_REQUESTS: 2   // New setting to limit concurrent requests
};

// Create a throttled queue that allows only a certain number of requests per second
// 4 requests every 1 second (Helius free tier allows 5 RPS, we're being conservative)
const rpcThrottler = throttledQueue(4, 1000);

function DarkModeToggle() {
  const [darkMode, setDarkMode] = useState(true);

  useEffect(() => {
    document.documentElement.classList.add('dark');
  }, []);

  useEffect(() => {
    if (darkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }, [darkMode]);

  return (
    <button
      onClick={() => setDarkMode(!darkMode)}
      className="fixed top-4 right-4 p-2 rounded-lg bg-geist-accent-200 dark:bg-geist-accent-700 hover:opacity-90 transition-all"
    >
      {darkMode ? 'ðŸŒž' : 'ðŸŒ™'}
    </button>
  );
}

function WalletInputs({ walletAddresses, onChange }) {
  const addWallet = () => {
    onChange([...walletAddresses, '']);
  };

  const removeWallet = (index) => {
    const updated = walletAddresses.filter((_, i) => i !== index);
    onChange(updated);
  };

  const updateWallet = (index, value) => {
    const updated = walletAddresses.map((addr, i) => 
      i === index ? value : addr
    );
    onChange(updated);
  };

  return (
    <div className="space-y-4">
      {walletAddresses.map((address, index) => (
        <div key={index} className="flex gap-2">
          <input
            type="text"
            value={address}
            onChange={(e) => updateWallet(index, e.target.value)}
            className="input"
            placeholder="Solana Wallet Address"
          />
          {index > 0 && (
            <button
              onClick={() => removeWallet(index)}
              className="btn btn-secondary"
            >
              Remove
            </button>
          )}
        </div>
      ))}
      <button onClick={addWallet} className="btn btn-primary">
        Add Wallet
      </button>
    </div>
  );
}

function App({ user }) {
  const { user: authUser } = useAuth();
  
  // Move state declarations above the useEffect
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    walletAddresses: [''],
    walletNames: ['My Wallet'],
    salary: '',
    stockIncome: '',
    realEstateIncome: '',
    dividends: ''
  });

  const [loading, setLoading] = useState(false);
  const [loadingStep, setLoadingStep] = useState(''); // Add this state for tracking processing steps
  const [results, setResults] = useState(null);
  const [transactions, setTransactions] = useState([]);
  const [loadingProgress, setLoadingProgress] = useState(0);
  const [showLandingPage, setShowLandingPage] = useState(!user); // Initialize based on authentication status
const [bypassCache, setBypassCache] = useState(false);
  const [rateLimitInfo, setRateLimitInfo] = useState({
    isLimited: false,
    retryCount: 0,
    nextRetryTime: null,
    message: ''
  });
  
  // Add state for selected wallet
  const [selectedWallet, setSelectedWallet] = useState('all');
  
  // Add onboarding step tracking
  const [onboardingStep, setOnboardingStep] = useState(0);
  
  // Add states for UI and tracking
  const [showUserInfoPage, setShowUserInfoPage] = useState(false);
  const [appLoaded, setAppLoaded] = useState(false);
  const [walletBalances, setWalletBalances] = useState({});
  const [loadingBalances, setLoadingBalances] = useState(false);
  const [loadingTransactions, setLoadingTransactions] = useState(false);
  const [userProfile, setUserProfile] = useState(null);
  const [currentPage, setCurrentPage] = useState('dashboard');
  const [showWalletInputs, setShowWalletInputs] = useState(false);
  const [activeSection, setActiveSection] = useState('dashboard'); // To track which section is active
  
  // Add state for tracking wallet processing status
  const [walletProcessingStatus, setWalletProcessingStatus] = useState({
    currentWallet: null,
    queuedWallets: [],
    completedWallets: [],
    processingAll: false
  });
  
  // Create refs for functions to break circular dependencies
  const analyzeTaxesRef = useRef(null);
  const processNextWalletInQueueRef = useRef(null);
  const queueWalletForProcessingRef = useRef(null);
  
  // Initialize refs after all functions are defined
  useEffect(() => {
    // Use a small timeout to ensure all functions are defined
    const timer = setTimeout(() => {
      // At this point, all functions should be defined
      
      // Define the real queueWalletForProcessing function
      queueWalletForProcessingRef.current = (walletAddress) => {
        if (!walletAddress) {
          console.error("Cannot process empty wallet address");
          return Promise.resolve();
        }
        
        // Use the improved wallet validation from solanaConnectionService
        if (!validateWalletAddress(walletAddress)) {
          console.error(`Invalid Solana wallet address: ${walletAddress}`);
          return Promise.resolve();
        }
        
        console.log(`Queueing wallet for processing: ${walletAddress}`);
        
        try {
          // Don't add if it's already in the queue or currently processing
          if (walletProcessingStatus.currentWallet === walletAddress) {
            console.log(`Wallet ${walletAddress} is already being processed`);
            return Promise.resolve();
          }
          
          if (walletProcessingStatus.queuedWallets.includes(walletAddress)) {
            console.log(`Wallet ${walletAddress} is already queued for processing`);
            return Promise.resolve();
          }
          
          // Clear any existing wallet-specific data to ensure a fresh load
          setTransactions([]);
          
          // Switch to wallet display view
          setActiveSection('transactions');
          
          // Select this wallet for display
          setSelectedWallet(walletAddress);
          
          // Update wallet processing status
          setWalletProcessingStatus(prev => {
            // If already processing this wallet, don't change anything
            if (prev.currentWallet === walletAddress) {
              return prev;
            }
            
            // If already in queue, don't add again
            if (prev.queuedWallets.includes(walletAddress)) {
              return prev;
            }
            
            // If no current wallet, set this as current
            if (!prev.currentWallet) {
              // Start processing immediately
              console.log(`Starting immediate processing of wallet: ${walletAddress}`);
              setTimeout(() => {
                analyzeTaxes(walletAddress);
              }, 100);
              
              return {
                ...prev,
                currentWallet: walletAddress,
                completedWallets: prev.completedWallets.filter(addr => addr !== walletAddress)
              };
            }
            
            // Otherwise add to queue
            console.log(`Adding ${walletAddress} to processing queue`);
            return {
              ...prev,
              queuedWallets: [...prev.queuedWallets, walletAddress],
              completedWallets: prev.completedWallets.filter(addr => addr !== walletAddress)
            };
          });
          
          return Promise.resolve();
        } catch (error) {
          console.error(`Error queueing wallet ${walletAddress}:`, error);
          return Promise.resolve();
        }
      };
      
      // At this point, all functions should be defined
      // Implement the real functions first
      const realAnalyzeTaxes = async (specificWalletAddress = null) => {
        console.log('Starting tax analysis for', specificWalletAddress || 'all wallets');
        
        // Set initial loading state
        setLoading(true);
        setLoadingProgress(0);
        
        // Check connection status before proceeding
        const connectionIsHealthy = await checkConnectionStatus();
        if (!connectionIsHealthy) {
          console.error("Cannot proceed with tax analysis due to connection issues");
          setLoading(false);
      return;
    }
    
        try {
          // Clear existing transactions if this is processing all wallets
          let allTransactions = [];
          
          // Filter valid wallet addresses (length >= 32)
          const validWalletAddresses = specificWalletAddress 
            ? [specificWalletAddress]
            : formData.walletAddresses.filter(addr => addr && addr.length >= 32);
          
          console.log('Processing wallets:', validWalletAddresses);
          
          // Update wallet processing status based on specific or all wallets
          if (specificWalletAddress) {
            // IMPORTANT: Don't remove the wallet from the queue here
            // We'll only update currentWallet but leave the queue intact
            setWalletProcessingStatus(prev => {
              // Don't modify if already processing this wallet
              if (prev.currentWallet === specificWalletAddress) {
                return prev;
              }
              
              console.log('Current queue before processing specific wallet:', 
                { current: prev.currentWallet, queued: prev.queuedWallets, completed: prev.completedWallets });
              
              // Keep the wallet in the queue if it's there, just set it as current
              return {
                currentWallet: specificWalletAddress,
                // Don't filter out the specificWalletAddress from the queue
                queuedWallets: prev.queuedWallets,
                completedWallets: prev.completedWallets.filter(addr => addr !== specificWalletAddress),
                processingAll: false
              };
            });
          } else {
            // If processing all wallets, set up a processing queue
            if (validWalletAddresses.length > 0) {
              setWalletProcessingStatus({
                currentWallet: validWalletAddresses[0],
                queuedWallets: validWalletAddresses.slice(1),
                completedWallets: [],
                processingAll: true
              });
            }
          }
          
          if (validWalletAddresses.length > 0) {
            const userWallets = new Set(formData.walletAddresses.filter(addr => addr && addr.length >= 32));
            
            // Process wallets sequentially with delays
            for (let i = 0; i < validWalletAddresses.length; i++) {
              const walletAddress = validWalletAddresses[i];
              
              // Update current processing wallet
              if (!specificWalletAddress) {
                console.log(`Processing wallet ${i+1}/${validWalletAddresses.length}: ${walletAddress}`);
                setWalletProcessingStatus(prev => ({
                  ...prev,
                  currentWallet: walletAddress,
                  queuedWallets: validWalletAddresses.slice(i + 1),
                  completedWallets: prev.completedWallets
                }));
              }
              
              try {
                // Call fetchSolanaTransactions to get wallet transactions
                const walletTransactions = await fetchSolanaTransactions(walletAddress);
                console.log(`Fetched ${walletTransactions?.length || 0} transactions for wallet: ${walletAddress}`);
                
                // Make transactions available in window object for UI and other components
                window.transactions = walletTransactions;
                
                // Get the wallet name
                const walletName = formData.walletNames[formData.walletAddresses.indexOf(walletAddress)] || `Wallet ${i+1}`;
                
                // Tag transactions with wallet information
                const taggedTransactions = walletTransactions.map(tx => {
                  // Find if this is an internal transfer and identify destination wallet
                  const destinationWalletAddress = tx.accounts.find(account => 
                    account !== walletAddress && userWallets.has(account)
                  );
                  
                  // Get destination wallet name if this is an internal transfer
                  let destinationWalletName = null;
                  if (destinationWalletAddress) {
                    const destIndex = formData.walletAddresses.findIndex(addr => addr === destinationWalletAddress);
                    destinationWalletName = destIndex >= 0 ? formData.walletNames[destIndex] : 'Unknown Wallet';
                  }
                  
                  return {
                    ...tx,
                    sourceWallet: walletAddress,
                    sourceWalletName: walletName,
                    isInternalTransfer: !!destinationWalletAddress,
                    destinationWallet: destinationWalletAddress,
                    destinationWalletName: destinationWalletName
                  };
                });
                
                // For a specific wallet, replace transactions rather than append
                if (specificWalletAddress) {
                  // Filter out old transactions for this wallet if they exist
                  const otherWalletTxs = allTransactions.filter(tx => tx.sourceWallet !== specificWalletAddress);
                  allTransactions = [...otherWalletTxs, ...taggedTransactions];
                } else {
                  allTransactions = [...allTransactions, ...taggedTransactions];
                }
                
                setLoadingProgress((i + 1) / validWalletAddresses.length * 100);
                
                // Mark this wallet as completed
                if (!specificWalletAddress) {
                  setWalletProcessingStatus(prev => ({
                    ...prev,
                    completedWallets: [...prev.completedWallets, walletAddress]
                  }));
                } else {
                  // For single wallet processing, mark it as completed when done
                  setWalletProcessingStatus(prev => {
                    // Log the current state before updating
                    console.log('Completing wallet processing for:', specificWalletAddress);
                    console.log('Current queue before completion:', 
                      { current: prev.currentWallet, queued: prev.queuedWallets, completed: prev.completedWallets });
                    
                    const updatedStatus = {
                      ...prev,
                      currentWallet: null,
                      // Now we can safely remove from the queue as processing is complete
                      queuedWallets: prev.queuedWallets.filter(addr => addr !== specificWalletAddress),
                      // Add the wallet to completed wallets if not already there
                      completedWallets: prev.completedWallets.includes(specificWalletAddress) 
                        ? prev.completedWallets 
                        : [...prev.completedWallets, specificWalletAddress]
                    };
                    
                    // Process the next wallet in the queue if there are any
                    if (prev.queuedWallets.length > 0) {
                      const nextWallet = prev.queuedWallets[0];
                      const remainingQueue = prev.queuedWallets.slice(1);
                      
                      console.log('Scheduling next wallet for processing:', nextWallet);
                      console.log('Remaining queue:', remainingQueue);
                      
                      // Start processing the next wallet in the queue
                      setTimeout(() => {
                        analyzeTaxes(nextWallet);
                      }, 500); // Small delay before starting the next wallet
                      
                      // Update the queue
                      updatedStatus.currentWallet = nextWallet;
                      updatedStatus.queuedWallets = remainingQueue;
                    }
                    
                    return updatedStatus;
                  });
                }
                
                // Set transactions after each wallet is processed so user can see
                // partial results while other wallets are loading
                const tempTxs = [...allTransactions];
                tempTxs.sort((a, b) => a.timestamp - b.timestamp);
                
                // Import and use groupTransactions from transactionUtils
                const { transactions: groupedTxs, gasFees } = await groupTransactions(tempTxs);
                setTransactions(groupedTxs);
                
                // Save transactions to Supabase if user is logged in
                if (authUser && taggedTransactions.length > 0) {
                  try {
                    await saveTransactionsToSupabase(walletAddress, taggedTransactions);
      } catch (error) {
                    console.error("Error saving transactions to Supabase:", error);
                  }
                }
                
                // Add delay between wallet processing
                if (i < validWalletAddresses.length - 1) {
                  await sleep(RATE_LIMIT.WALLET_DELAY);
                }
              } catch (error) {
                console.error(`Error processing wallet ${walletAddress}: ${error.message}`);
                
                // Even if there's an error, mark this wallet as completed to move on
                if (!specificWalletAddress) {
                  setWalletProcessingStatus(prev => ({
                    ...prev,
                    completedWallets: [...prev.completedWallets, walletAddress]
                  }));
                } else if (specificWalletAddress === walletAddress) {
                  // For single wallet processing with error, still mark it as completed
                  setWalletProcessingStatus(prev => {
                    const updatedStatus = {
                      ...prev,
                      currentWallet: null,
                      completedWallets: prev.completedWallets.includes(specificWalletAddress)
                        ? prev.completedWallets
                        : [...prev.completedWallets, specificWalletAddress]
                    };
                    
                    // Process the next wallet in the queue if there are any
                    if (prev.queuedWallets.length > 0) {
                      const nextWallet = prev.queuedWallets[0];
                      const remainingQueue = prev.queuedWallets.slice(1);
                      
                      // Start processing the next wallet in the queue
                      setTimeout(() => {
                        analyzeTaxes(nextWallet);
                      }, 500); // Small delay before starting the next wallet
                      
                      // Update the queue
                      updatedStatus.currentWallet = nextWallet;
                      updatedStatus.queuedWallets = remainingQueue;
                    }
                    
                    return updatedStatus;
                  });
                }
                
                // Continue with next wallet
              }
            }
            
            // Sort all transactions by timestamp
            allTransactions.sort((a, b) => a.timestamp - b.timestamp);
            
            // Group related transactions (internal transfers, swaps, etc.)
            const { transactions: groupedTxs, gasFees } = await groupTransactions(allTransactions);
            
            // Process transactions for tax calculations
            const processedTransactions = groupedTxs.map(tx => {
              if (tx.isInternalTransfer) {
                return {
                  ...tx,
                  type: TRANSACTION_TYPES.INTERNAL_TRANSFER,
                  taxableEvent: false, // Internal transfers aren't taxable
                  realizedGain: 0
                };
              }
              return tx;
            });
            
            console.log('Setting processed transactions:', processedTransactions.length);
            // Ensure transactions are set both in state and globally accessible
            window.transactions = processedTransactions;
            setTransactions(processedTransactions);
            
            // Calculate tax implications
            const nonGasTransactions = processedTransactions.filter(tx => 
              tx.type !== 'gas' && !tx.isInternalTransfer
            );
            
            // Get unique tokens from transactions
            const uniqueTokens = calculateUniqueTokens(processedTransactions);
            
            const taxResults = {
              totalCapitalGains: nonGasTransactions.reduce((sum, tx) => sum + (tx.realizedGain || 0), 0),
              shortTermGains: nonGasTransactions.filter(tx => tx.isShortTerm).reduce((sum, tx) => sum + (tx.realizedGain || 0), 0),
              longTermGains: nonGasTransactions.filter(tx => !tx.isShortTerm).reduce((sum, tx) => sum + (tx.realizedGain || 0), 0),
              estimatedTaxes: nonGasTransactions.reduce((sum, tx) => sum + ((tx.realizedGain || 0) * 0.30), 0),
              transactionsByMonth: [],
              crypto: {
                totalTransactions: nonGasTransactions.length,
                uniqueTokens,
                totalVolume: calculateVolume(nonGasTransactions),
                realizedGains: nonGasTransactions.reduce((sum, tx) => sum + (tx.realizedGain || 0), 0),
                estimatedTax: nonGasTransactions.reduce((sum, tx) => sum + ((tx.realizedGain || 0) * 0.30), 0),
                gasFees: gasFees,
                internalTransfers: processedTransactions.filter(tx => tx.isInternalTransfer).length
              },
              traditional: {
                totalIncome: Number(formData.salary) || 0,
                stockIncome: Number(formData.stockIncome) || 0,
                realEstateIncome: Number(formData.realEstateIncome) || 0,
                dividends: Number(formData.dividends) || 0,
                totalTraditionalIncome: (
                  Number(formData.salary) || 0) + 
                  (Number(formData.stockIncome) || 0) + 
                  (Number(formData.realEstateIncome) || 0) + 
                  (Number(formData.dividends) || 0
                )
              }
            };
            
            // Set the tax results
            setResults(taxResults);
          }
          
          // Return success
          return true;
        } catch (error) {
          console.error("Error analyzing taxes:", error);
          return false;
        } finally {
          setLoading(false);
        }
      };
      
      // Implement the real processNextWalletInQueue function
      const realProcessNextWalletInQueue = async () => {
        console.log('Processing next wallet in queue');
        
        // Access the state through the setter function to ensure we have the latest state
        let currentStatus = null;
        setWalletProcessingStatus(prev => {
          // Store the current status for checking
          currentStatus = prev;
          return prev;
        });
        
        // Wait for the state update to complete
        await new Promise(resolve => setTimeout(resolve, 0));
        
        // Check if there are any wallets in the queue
        if (!currentStatus || !currentStatus.queuedWallets || currentStatus.queuedWallets.length === 0) {
          console.log('No wallets in queue');
          return false;
        }
        
        // Get the next wallet from the queue
        const nextWallet = currentStatus.queuedWallets[0];
        console.log('Found wallet in queue, processing:', nextWallet);
        
        // Update the current wallet while keeping it in the queue
        setWalletProcessingStatus(prev => ({
          ...prev,
          currentWallet: nextWallet
        }));
        
        // Process the wallet - analyzeTaxes will handle removing from queue when done
        try {
          await realAnalyzeTaxes(nextWallet);
          return true;
        } catch (error) {
          console.error('Error processing wallet:', error);
          // Even on error, try to update the status to avoid stuck state
          setWalletProcessingStatus(prev => {
            // Only modify the state if the nextWallet is still the currentWallet
            if (prev.currentWallet === nextWallet) {
              const updatedStatus = {
                ...prev,
                currentWallet: null,
                queuedWallets: prev.queuedWallets.filter(addr => addr !== nextWallet),
                completedWallets: [...prev.completedWallets, nextWallet]
              };
              
              // Check if there are more wallets to process
              if (updatedStatus.queuedWallets.length > 0) {
                // Schedule the next wallet processing
                setTimeout(() => {
                  console.log('Processing next wallet after error recovery');
                  realProcessNextWalletInQueue();
                }, 500);
              }
              
              return updatedStatus;
            }
            return prev;
          });
          return false;
        }
      };
      
      // Now assign our implementations to the refs
      analyzeTaxesRef.current = realAnalyzeTaxes;
      processNextWalletInQueueRef.current = realProcessNextWalletInQueue;
    }, 100);
    
    return () => clearTimeout(timer);
  }, [formData.walletAddresses, setLoading, setLoadingProgress, setWalletProcessingStatus, walletProcessingStatus]);
  
  // Define walletMap (mapping from wallet addresses to wallet names)
  const walletMap = useMemo(() => {
    const map = {};
    formData.walletAddresses.forEach((address, index) => {
      if (address && address.length > 0) {
        map[address] = formData.walletNames[index] || `Wallet ${index + 1}`;
      }
    });
    return map;
  }, [formData.walletAddresses, formData.walletNames]);
  
  // Set app as loaded after a small delay
  useEffect(() => {
    const timer = setTimeout(() => {
      setAppLoaded(true);
    }, 100);
    return () => clearTimeout(timer);
  }, []);

  // Fetch wallet balances when app loads or when showing the dashboard
  useEffect(() => {
    if (appLoaded && !showUserInfoPage) {
      const validWalletAddresses = formData.walletAddresses.filter(addr => addr.length >= 32);
      if (validWalletAddresses.length > 0) {
        fetchWalletBalances();
      }
    }
  }, [appLoaded, showUserInfoPage, formData.walletAddresses]);

  // Start onboarding process
  const startOnboarding = () => {
    setShowLandingPage(false);
    setOnboardingStep(1);
  };

  // Move to traditional income step
  const goToTraditionalIncomeStep = () => {
    // Start loading wallet balances in background
    if (formData.walletAddresses.filter(addr => addr.length >= 32).length > 0) {
      fetchWalletBalances();
    }
    setOnboardingStep(2);
  };

  // Skip traditional income and go to dashboard
  const skipToResults = async () => {
    setOnboardingStep(3);
    
    // Load wallet balances and then start analyzing transactions
    const validWalletAddresses = formData.walletAddresses.filter(addr => addr.length >= 32);
    if (validWalletAddresses.length > 0) {
      await fetchWalletBalances();
      console.log('Starting wallet analysis after balances are fetched...');
      // Process wallets one by one for more reliable processing
      for (const walletAddress of validWalletAddresses) {
        console.log(`Queueing wallet: ${walletAddress}`);
        queueWalletForProcessing(walletAddress);
        // Small delay between queueing wallets
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
  };

  // Go back to previous step
  const goBackToPreviousStep = () => {
    if (onboardingStep > 1) {
      setOnboardingStep(onboardingStep - 1);
    } else {
      setShowLandingPage(true);
      setOnboardingStep(0);
    }
  };

  // Handle wallet name changes
  const handleWalletNameChange = (index, value) => {
    const updatedNames = [...formData.walletNames];
    updatedNames[index] = value;
    setFormData(prev => ({
      ...prev,
      walletNames: updatedNames
    }));
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  const getFiscalYearDates = () => {
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth() + 1; // JavaScript months are 0-based
  
    // If we're in the first half of the calendar year, use previous year
    const fiscalYear = currentMonth >= 7 ? currentYear : currentYear - 1;
    
    const startDate = new Date(`${fiscalYear}-07-01`);
    const endDate = new Date(`${fiscalYear + 1}-06-30`);
  
    return { startDate, endDate };
  };
  
  const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

  const clearAllTransactionCache = () => {
    console.log('Clearing all transaction cache...');
    // First, find all localStorage keys that start with our cache prefix
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(CACHE_KEY_PREFIX)) {
        keysToRemove.push(key);
      }
    }
    
    // Then remove them
    keysToRemove.forEach(key => {
      localStorage.removeItem(key);
    });
    
    console.log(`Cleared ${keysToRemove.length} cached items`);
    setTransactions([]);
    setResults(null);
    setLoadingProgress(0);
  };

  // Function to reset all application data (for testing)
  const resetAllAppData = async () => {
    console.log('Resetting all application data...');
    
    // Clear local cache
    clearAllTransactionCache();
    
    // Reset UI state
    setTransactions([]);
    setResults(null);
    setLoadingProgress(0);
    setBatchProgress({
      totalTransactions: 0,
      processedTransactions: 0,
      currentBatch: 0,
      totalBatches: 0,
      isComplete: true
    });
    
    // Clear Supabase data if user is logged in
    if (authUser) {
      try {
        // Import the function from databaseService
        const { deleteAllUserData } = await import('./services/databaseService');
        
        // Delete all user data from Supabase
        const result = await deleteAllUserData(authUser.id);
        
        if (result.success) {
          console.log('Successfully reset all Supabase data');
                      } else {
          console.error('Error resetting Supabase data:', result.error);
        }
      } catch (error) {
        console.error('Error importing or calling deleteAllUserData:', error);
      }
    }
    
    // Show confirmation to user
    alert('All application data has been reset successfully.');
  };

  const clearTransactionCache = () => {
    // Only clear cache for valid wallet addresses
    const validWalletAddresses = formData.walletAddresses.filter(addr => addr.length >= 32);
    
    if (validWalletAddresses.length === 0) {
      alert('Please add valid wallet addresses first.');
      return;
    }
    
    // Clear cache for these wallet addresses
    validWalletAddresses.forEach(address => {
      const cacheKey = `${address}_${getFiscalYearDates().startDate.getTime()}`;
      localStorage.removeItem(CACHE_KEY_PREFIX + cacheKey);
    });
    
    // Set bypassCache to true for the next analyze
    setBypassCache(true);
    
    // Reset transactions and results
    setTransactions([]);
    setResults(null);
    setLoadingProgress(0);
    
    alert('Cache cleared. Click "Calculate All Taxes" to refresh the data.');
  };

  const getFromCache = (key) => {
    if (bypassCache) return null;
    
    const cached = localStorage.getItem(CACHE_KEY_PREFIX + key);
    if (cached) {
      const { data, timestamp } = JSON.parse(cached);
      if (Date.now() - timestamp < CACHE_DURATION) {
        return data;
      }
      localStorage.removeItem(CACHE_KEY_PREFIX + key);
    }
    return null;
  };

  const saveToCache = (key, data) => {
    localStorage.setItem(`${CACHE_KEY_PREFIX}${key}`, JSON.stringify({
      data,
      timestamp: Date.now()
    }));
  };

  // Enhanced fetchWithRetry function to better handle rate limits
  const fetchWithRetry = async (fn, maxRetries = 5, initialDelay = 1000) => {
    let retries = 0;
    let lastError = null;
    let retryDelay = initialDelay;
    
    const isHeliusApiError = (error) => {
      if (!error) return false;
      const msg = error.message || '';
      return msg.includes('Method not found') || 
             msg.includes('Helius API') || 
             (error.heliusError === true);
    };
    
    console.log(`Making RPC call with retry logic`);
    
    while (retries <= maxRetries) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;
        
        const errorMessage = error.message || '';
        const responseText = error.responseText || '';
        
        // Mark this error as a Helius API error for future detection
        if (errorMessage.includes('Method not found') || responseText.includes('Method not found')) {
          error.heliusError = true;
        }
        
        // Special case for Helius API errors - don't retry the same method call
        if (isHeliusApiError(error)) {
          console.error(`Helius API error detected, not retrying with same method: ${errorMessage}`);
          throw error; // Don't retry Helius API method errors
        }
        
        const isRateLimited = 
          errorMessage.includes('429') || 
          errorMessage.includes('rate limit') || 
          errorMessage.includes('too many requests');
          
        const isNetworkError = 
          errorMessage.includes('network') || 
          errorMessage.includes('ECONNRESET') || 
          errorMessage.includes('ETIMEDOUT') || 
          errorMessage.includes('failed to fetch');
        
        if (retries === maxRetries) {
          console.error(`Max retries (${maxRetries}) reached. Last error: ${errorMessage}`);
          throw error;
        }
        
        if (isRateLimited) {
          console.warn(`Rate limit hit (retry ${retries + 1}/${maxRetries}). Waiting ${retryDelay}ms before retrying...`);
          
          // Update the UI with rate limit info
          setRateLimitInfo({
            isRateLimited: true,
            message: `Rate limit reached. Retrying in ${Math.ceil(retryDelay/1000)}s...`,
            nextRetryTime: new Date(Date.now() + retryDelay)
          });
        } else if (isNetworkError) {
          console.warn(`Network error (retry ${retries + 1}/${maxRetries}): ${errorMessage}. Waiting ${retryDelay}ms before retrying...`);
        } else {
          console.warn(`Error (retry ${retries + 1}/${maxRetries}): ${errorMessage}. Waiting ${retryDelay}ms before retrying...`);
        }
        
        await new Promise(resolve => setTimeout(resolve, retryDelay));
        retryDelay *= 2; // Exponential backoff
        retries++;
      }
    }
    
    // We should never get here due to the final throw in the catch block
    throw lastError || new Error('Max retries reached');
  };

  // Inside fetchSolanaTransactions, modify to try the direct approach first
  const fetchSolanaTransactions = async (walletAddress) => {
    console.log(`Fetching Solana transactions for wallet: ${walletAddress}`);
    
    // Validate wallet address first
    if (!validateWalletAddress(walletAddress)) {
      console.error(`Invalid wallet address format: ${walletAddress}`);
      return [];
    }
    
    // Debug mode checks...
    // ...existing debug mode code...
    
    // Reset batch progress
    setBatchProgress({
      currentBatch: 0,
      totalBatches: 0,
      batchSize: 0,
      processedInBatch: 0,
      totalTransactions: 0,
      processedTransactions: 0,
      isComplete: false
    });
    
    setLoading(true);
    setLoadingStep('Fetching transactions...');
    
    // Check cache first
    const cacheKey = `${CACHE_KEY_PREFIX}${walletAddress}_${getFiscalYearDates().startDate.getTime()}`;
    const cachedData = getFromCache(cacheKey);
    
    if (cachedData) {
      console.log(`Found ${cachedData.length} cached transactions for ${walletAddress}`);
      setLoading(false);
      setLoadingStep('');
      return cachedData;
    }
    
    // Approach 1: Try using the direct wallet transactions endpoint first (simplest)
    try {
      console.log(`Trying direct wallet transactions approach for ${walletAddress}...`);
      
      const directTransactions = await fetchWalletTransactionsFromHelius(walletAddress, 100);
      
      if (directTransactions && directTransactions.length > 0) {
        console.log(`Successfully fetched ${directTransactions.length} transactions via direct endpoint`);
        
        // Process the transactions
        setLoading(false);
        setLoadingStep('');
        
        // Save to cache
        saveToCache(cacheKey, directTransactions);
        
        // Update batch progress to show completion
        setBatchProgress(prev => ({
          ...prev,
          isComplete: true,
          totalTransactions: directTransactions.length,
          processedTransactions: directTransactions.length
        }));
        
        return directTransactions;
      } else {
        console.warn(`No transactions found via direct wallet endpoint for ${walletAddress}, trying signature-based approach...`);
        // Continue to approach 2
      }
    } catch (directError) {
      console.error(`Direct wallet transactions approach failed:`, directError.message);
      console.log(`Falling back to signature-based approach...`);
      // Continue to approach 2
    }
    
    // Approach 2: Fetch transaction signatures and then individual transactions
    try {
      console.log(`Using signature-based approach for ${walletAddress}`);
      
      // Reset connection to ensure we're not using a stale connection
      resetConnection();
      
      // Get a fresh connection
      const connection = getConnection(true);
      
      // Constants for batching
      const SIGNATURE_BATCH_SIZE = 50;  // Number of signatures to fetch at once
      const DISPLAY_BATCH_SIZE = 10;    // Number of transactions to process and display at once
      const MAX_TRANSACTIONS = 5000;    // Maximum number of transactions to process
      
      let beforeSignature = null;
      let allTransactions = [];
      let batchNumber = 1;
      let fetchingComplete = false;
      let processedSignatures = new Set(); // Track which signatures we've processed
      
      // Process and display transactions in smaller batches
      const processAndDisplayBatch = async (signatures, batchNumber) => {
        if (!signatures || signatures.length === 0) return [];
        
        console.log(`Processing display batch ${batchNumber} with ${signatures.length} signatures`);
        
        // Update loading status
        setLoadingStep(`Processing batch ${batchNumber} with ${signatures.length} transactions...`);
        
        // Update batch progress
        setBatchProgress(prev => ({
          ...prev,
          currentBatch: batchNumber,
          batchSize: signatures.length,
          processedInBatch: 0
        }));
        
        // Fetch transactions for all signatures in parallel
        const transactionPromises = signatures.map((sig, index) => {
          return fetchWithRetry(async () => {
            if (processedSignatures.has(sig.signature)) {
              console.log(`Skipping already processed signature: ${sig.signature.substring(0, 8)}...`);
              return null;
            }
            
            processedSignatures.add(sig.signature);
            
            try {
              console.log(`Fetching transaction ${sig.signature.substring(0, 8)}...`);
              
              let tx = null;
              let txData = null;
              
              try {
                // First try Helius enhanced transactions API
                const txResponse = await fetch(HELIUS_TRANSACTION_URL, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ 
                    transactions: [sig.signature] 
                  })
                });
                
                if (!txResponse.ok) {
                  const errorText = await txResponse.text();
                  console.error(`Transaction fetch error response:`, errorText);
                  throw new Error(`Failed to fetch transaction: ${txResponse.status} ${txResponse.statusText} - ${errorText}`);
                }
                
                txData = await txResponse.json();
                
                if (!txData || !txData[0]) {
                  console.warn(`Transaction ${sig.signature.substring(0, 8)}... not found or invalid response`, JSON.stringify(txData));
                  throw new Error('Empty or invalid response from Helius transactions API');
                }
                
                tx = txData[0];
              } catch (heliusError) {
                // Fallback to direct Solana web3.js API
                console.warn(`Helius transactions API failed, falling back to direct connection: ${heliusError.message}`);
                
                try {
                  // Get a fresh connection
                  resetConnection();
                  const connection = getConnection(true);
                  
                  // Fetch the transaction directly using the Solana web3.js API
                  const txResponse = await connection.getTransaction(sig.signature, {
                    maxSupportedTransactionVersion: 0,
                    commitment: 'confirmed'
                  });
                  
                  if (!txResponse) {
                    console.error(`Transaction ${sig.signature.substring(0, 8)}... not found via direct connection`);
                    return null;
                  }
                  
                  console.log(`Successfully fetched transaction ${sig.signature.substring(0, 8)}... via direct connection`);
                  
                  // Format to match our expected structure
                  tx = {
                    blockTime: txResponse.blockTime,
                    meta: txResponse.meta,
                    transaction: txResponse.transaction,
                    slot: txResponse.slot,
                    version: txResponse.version
                  };
                } catch (connectionError) {
                  console.error(`Direct connection fallback also failed: ${connectionError.message}`);
                  return null;
                }
              }
              
      console.log("Checking Solana connection status...");
      
      // Simple test to verify connection is working
      const blockHeight = await executeWithRetry(async () => {
        return await connection.getBlockHeight();
      });
      
      console.log(`Solana connection is healthy. Current block height: ${blockHeight}`);
      
      // Also try to check Helius API health directly
      try {
        const healthStatus = await checkHeliusHealth();
        console.log(`Helius API health status: ${healthStatus}`);
      } catch (healthError) {
        // Log but continue as the main connection is working
        console.warn(`Helius API health check failed, but main connection is working: ${healthError.message}`);
      }
      
      return true;
    } catch (error) {
      console.error("Solana connection check failed:", error.message);
      
      // Update UI with error information
      setRateLimitInfo({
        isRateLimited: true,
        message: `Connection Error: ${error.message}. Please try again later.`,
        nextRetryTime: new Date(Date.now() + 5000)
      });
      
      return false;
    }
  } // removed semicolon
